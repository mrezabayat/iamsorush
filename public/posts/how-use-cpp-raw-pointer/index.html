<!DOCTYPE html>
<html lang="en-us">

<head>
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-179561110-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());
        gtag('config', 'UA-179561110-1');
    </script>
    
   
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge;chrome=1"> 
    <link rel="icon" href="/images/me.gif" type="image/gif">
    <title>How to use C&#43;&#43; raw pointers properly?</title>
    
    <meta name="description" content="A pointer is an 8-byte type on a 64-bit machine that holds the memory address of a target object. Here, I  mention the most useful characteristics of pointers with examples."> 
    
    <meta name="author" content="map[name:Sorush Khajepor]">
    
    
    
    
    <link rel="stylesheet" href="https://iamsorush.com/css/style.min.css">
    
    
    
    <style>.icon{width:32px}.mr-1{margin-right:.5em}.mb-1{margin-bottom:.5em}.single-image{display:block;background-repeat:no-repeat;background-position:50%;margin-left:auto;margin-right:auto}.banner{width:100%;min-height:180px;background-image:url(/images/banner_430.jpg);padding:1em 0 2em 0}@media(min-width:430px){.banner{background-image:url(/images/banner.jpg)}}</style>
    

</head>

<body>
    
<div class="read-progress-container">
	<div class="progress-bar" id="myBar"></div>
</div>
<header class="header-black">
	<div class="container">

	<div class="home__header-grid"> 
		<div class="display-flex flex-column left-horizontal">
			<a class="scale-left-sm" href="https://iamsorush.com/">Sorush Khajepor</a>
			<span class="text-shadow-1">Researcher & Developer</span>
		</div>
		<div class="center justify-md-end">	
			<a href="https://github.com/sorush-khajepor" class="mr-1 icon" aria-label="Github">
				<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path fill="white" d="M512 0C229.25 0 0 229.25 0 512c0 226.25 146.688 418.125 350.156 485.812 25.594 4.688 34.938-11.125 34.938-24.625 0-12.188-0.469-52.562-0.719-95.312C242 908.812 211.906 817.5 211.906 817.5c-23.312-59.125-56.844-74.875-56.844-74.875-46.531-31.75 3.53-31.125 3.53-31.125 51.406 3.562 78.47 52.75 78.47 52.75 45.688 78.25 119.875 55.625 149 42.5 4.654-33 17.904-55.625 32.5-68.375C304.906 725.438 185.344 681.5 185.344 485.312c0-55.938 19.969-101.562 52.656-137.406-5.219-13-22.844-65.094 5.062-135.562 0 0 42.938-13.75 140.812 52.5 40.812-11.406 84.594-17.031 128.125-17.219 43.5 0.188 87.312 5.875 128.188 17.281 97.688-66.312 140.688-52.5 140.688-52.5 28 70.531 10.375 122.562 5.125 135.5 32.812 35.844 52.625 81.469 52.625 137.406 0 196.688-119.75 240-233.812 252.688 18.438 15.875 34.75 47 34.75 94.75 0 68.438-0.688 123.625-0.688 140.5 0 13.625 9.312 29.562 35.25 24.562C877.438 930 1024 738.125 1024 512 1024 229.25 794.75 0 512 0z"/></svg>
			</a>
			<a href="https://twitter.com/KhSorush" class="mr-1 icon" aria-label="Twitter">
				<svg id="Logo_FIXED" data-name="Logo â€” FIXED" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 400"><defs><style>.cls-1{fill:none;}.cls-2{fill:#1da1f2;}</style></defs><title>Twitter_Logo_Blue</title><rect class="cls-1" width="400" height="400"/><path class="cls-2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
			</a>
			<a href="https://scholar.google.co.uk/citations?user=16Y7-NsAAAAJ&hl=en" class="mr-1 icon" aria-label="Google Scholar">
				<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g data-name="Layer 2" id="Layer_2"><polygon fill="white" points="0.54 9 5 10.98 7 11.87 12 14.09 17 11.87 19 10.98 20 10.54 20 16 22 16 22 9.65 23.46 9 12 3.91 0.54 9"/><path fill="white" d="M18.45,18.89l.55-.27V13.17l-7,3.11L5,13.17v5.45l.55.27a14.45,14.45,0,0,0,12.9,0Z"/></g></svg>
			</a>
			<a href="https://stackoverflow.com/users/2543510/sorush" class="mr-1 icon" aria-label="Stackoverflow">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 120 120"><style>.st0{fill:#bcbbbb}.st1{fill:#f48023}</style><path class="st0" d="M84.4 93.8V70.6h7.7v30.9H22.6V70.6h7.7v23.2z"/><path class="st1" d="M38.8 68.4l37.8 7.9 1.6-7.6-37.8-7.9-1.6 7.6zm5-18l35 16.3 3.2-7-35-16.4-3.2 7.1zm9.7-17.2l29.7 24.7 4.9-5.9-29.7-24.7-4.9 5.9zm19.2-18.3l-6.2 4.6 23 31 6.2-4.6-23-31zM38 86h38.6v-7.7H38V86z"/></svg>
			</a>
			<a href="https://www.linkedin.com/in/sorushkh/" class="mr-1 icon" aria-label="Linkedin">
				<svg enable-background="new 0 0 32 32" height="32px" id="Layer_1" version="1.0" viewBox="0 0 32 32" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g><path d="M32,30c0,1.104-0.896,2-2,2H2c-1.104,0-2-0.896-2-2V2c0-1.104,0.896-2,2-2h28c1.104,0,2,0.896,2,2V30z" fill="#007BB5"/><g><rect fill="#FFFFFF" height="14" width="4" x="7" y="11"/><path d="M20.499,11c-2.791,0-3.271,1.018-3.499,2v-2h-4v14h4v-8c0-1.297,0.703-2,2-2c1.266,0,2,0.688,2,2v8h4v-7    C25,14,24.479,11,20.499,11z" fill="#FFFFFF"/><circle cx="9" cy="8" fill="#FFFFFF" r="2"/></g></g><g/><g/><g/><g/><g/><g/></svg>
			</a>
		</div>
    </div>
	</div>
</header>

<main>
	<article>
		<h1>How to use C&#43;&#43; raw pointers properly?</h1>
		<time>22 Feb 2020</time>
	</article>
	














<style>
    .post__hero{
        background-image: url('https://iamsorush.com/images/pointer_hu3d03a01dcc18bc5be0e67db3d8d209a6_319268_430x250_fill_q70_box_smart1.jpg');
        height: 250px;
    }
    @media (min-width: 430px) {
        .post__hero{
        background-image: url('https://iamsorush.com/images/pointer_hu3d03a01dcc18bc5be0e67db3d8d209a6_319268_1280x400_fill_q70_box_smart1.jpg');
        height: 400px;
        }
    }   
</style>
<div class="single-image post__hero"></div>
	<div class="article-nav" id="article-nav-id">
		<article class="overlay-top">
			<h2 id="introduction">Introduction</h2>
<p><em>C++</em> is used widely for high-performance computing. Mastering pointers is an important step in writing efficient code. In this post, I  mention the most useful characteristics of raw pointers with examples.</p>
<p>Here I focus only on raw pointers and assume the code we are working with doesn&rsquo;t allow smart pointers (<a href="https://iamsorush.com/posts/unique-pointers-cpp/">unique</a>, <a href="https://iamsorush.com/posts/shared-pointer-cpp/">shared</a> and <a href="https://iamsorush.com/posts/weak-pointer-cpp/">weak pointers</a>).</p>
<h2 id="definition">Definition</h2>
<p>A pointer is an 8-byte type on a 64-bit machine that holds the memory address of a target object.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span>  x <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;   <span style="color:#75715e">//  variable declaration
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p; <span style="color:#75715e">// pointer declaration
</span><span style="color:#75715e"></span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>x;  <span style="color:#75715e">// pointer stores address of x
</span><span style="color:#75715e"></span>cout<span style="color:#f92672">&lt;&lt;</span> p <span style="color:#f92672">&lt;&lt;</span>endl; <span style="color:#75715e">//0x7ffc52a21a84
</span><span style="color:#75715e"></span>cout<span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">&lt;&lt;</span>endl; <span style="color:#75715e">// 20 : dereferencing with * operator
</span></code></pre></div><p>In the above example, <code>p</code> at the beginning is declared but undefined (it points to somewhere we don&rsquo;t know); it then pointed to <code>x</code>. Roughly, the code is equivalent to the picture below</p>


<div style="text-align:center;">
<img src="/images/rawpointer1.png" style="max-width:100%;" />
</div>

<p>The pointer holds the memory address of <code>x</code>.  Using <code>*</code> operator, the pointer can be dereferenced to get the value of its target.</p>
<h2 id="memory-allocation">Memory Allocation</h2>
<p>A pointer is usually pointed to dynamically allocated memory on the heap, a scalar</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>;
</code></pre></div>

<div style="text-align:center;">
<img src="/images/rawpointer2.png" style="max-width:100%;" />
</div>

<p>or an array</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> q <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">5</span>];
</code></pre></div><h2 id="delete">Delete</h2>
<p>The allocated memory can be deleted (not the pointer itself)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>;
<span style="color:#66d9ef">delete</span> p; <span style="color:#75715e">// new int memory now deleted
</span></code></pre></div>

<div style="text-align:center;">
<img src="/images/rawpointer3.png" style="max-width:100%;" />
</div>

<p>To delete all elements of the array</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> q <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">5</span>];
<span style="color:#66d9ef">delete</span>[] q; <span style="color:#75715e">// All elements of array deleted
</span></code></pre></div><p>Note that they are not literally deleted, the memory is marked as free to be overwritten.</p>
<p>Remember that <code>new</code> ends with <code>delete</code>, <code>new[]</code> ends with <code>delete[]</code>. The compiler knows the number of elements of the array created via <code>new[]</code>, so <code>delete[]</code> doesn&rsquo;t need the number of elements.</p>
<p>Do not delete the dynamically created array using <code>delete</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> q <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">5</span>];
<span style="color:#66d9ef">delete</span> q; <span style="color:#75715e">// Error: only one element is deleted
</span></code></pre></div><p>Do not delete a stack memory that a pointer points to</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(){
  <span style="color:#66d9ef">int</span> x;
  <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p<span style="color:#f92672">=&amp;</span>x;
  <span style="color:#66d9ef">delete</span> p; <span style="color:#75715e">// Undefined Behaviour: deleting a memory on stack!
</span><span style="color:#75715e"></span>}
</code></pre></div><p>Do not double delete</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>;
<span style="color:#66d9ef">delete</span> p; <span style="color:#75715e">// target memory deleted
</span><span style="color:#75715e"></span><span style="color:#66d9ef">delete</span> p; <span style="color:#75715e">// error or undefined behaviour
</span></code></pre></div><h2 id="null-usage">Null usage</h2>
<p>There is no way to know if a pointer is deleted or not associated, therefore, I prefer to point the pointer to <code>nullptr</code> (or <code>NULL</code> for <em>C</em> and older than <em>C++11</em> compilers) when there is nothing to point to: at declaration and deletion. In this way, some <em>undefined behaviours</em> like double-delete are avoided.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>  <span style="color:#75715e">// declaration with null
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> q <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>; <span style="color:#75715e">// memory allocation
</span><span style="color:#75715e"></span><span style="color:#66d9ef">delete</span> q; <span style="color:#75715e">// removing allocated memory
</span><span style="color:#75715e"></span>q <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</code></pre></div><p><code>nullptr</code> is type-safe in comparison with <code>NULL</code>. In some <a href="https://stackoverflow.com/questions/20509734/null-vs-nullptr-why-was-it-replaced">cases</a>, compilers confuse the type of <code>NULL</code> with <code>int</code>. We can check if a pointer is null like below</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">if</span>(p<span style="color:#f92672">!=</span><span style="color:#66d9ef">nullptr</span>) {...}  <span style="color:#75715e">// C++11 and later
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span>(p<span style="color:#f92672">!=</span>NULL) {...} <span style="color:#75715e">// C and older C++ compilers
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (p) {...} <span style="color:#75715e">// the same as above lines
</span></code></pre></div><p>It should be noted that making a pointer null after delete hides the double-delete problem explained in the previous section. And it does not affect other pointers pointing to the same deleted memory. Some people don&rsquo;t like this convention read <a href="https://stackoverflow.com/questions/4190703/is-it-safe-to-delete-a-null-pointer">here</a>.</p>
<h2 id="memory-leak">Memory leak</h2>
<p>There is no memory management system for raw pointers. Therefore, not deleting the allocated memory of pointer explicitly causes memory leak:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> x;
<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>;
p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>x;  <span style="color:#75715e">// re-pointed but &#34;new int&#34; not deleted
</span></code></pre></div><p>In the above example, new int memory is an island in the sea of computer memory. We could only find it via <code>p</code> but, in the last line, <code>p</code> is pointed to another place, <code>x</code>. So we have a memory leak!</p>


<div style="text-align:center;">
<img src="/images/rawpointer4.png" style="max-width:100%;" />
</div>

<p>We have to remember to delete the allocated memory and then point the pointer to another target:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> x;
<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>;
<span style="color:#66d9ef">delete</span> p;
p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>x;
</code></pre></div><p>The same happens if the pointer goes out of scope</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// some code here
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>; <span style="color:#75715e">// p declared and given a new memory
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// do some stuff with p
</span><span style="color:#75715e"></span>}
<span style="color:#75715e">// p is destroyed here but new int memory is somewhere not deleted
</span></code></pre></div><p>Again we have to remember to delete it ourself:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">{
    <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p<span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>; <span style="color:#75715e">// p declared and given a new memory
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// do some stuff with p
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">delete</span> p;  <span style="color:#75715e">// the new int is deleted.
</span><span style="color:#75715e"></span>}
</code></pre></div><p>A pointer member of a class better be deleted in the destructor</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">A</span>{
    <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p;
    A(){p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>; cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;p is allocated memory.&#34;</span>;}
    <span style="color:#f92672">~</span>A(){<span style="color:#66d9ef">delete</span> p; cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;p is deleted.&#34;</span>;}
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(){
    A a; <span style="color:#75715e">// p is allocated memory.
</span><span style="color:#75715e"></span>} <span style="color:#75715e">// a.p is deleted
</span></code></pre></div><p>There is another situation that memory leaks:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>;

<span style="color:#75715e">// An exception is thrown by some code here!
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">delete</span> p; <span style="color:#75715e">// this line is not reached.
</span></code></pre></div><p>A raw pointer cannot handle this, you need to use smart pointers (see this <a href="https://stackoverflow.com/questions/24150472/c-avoiding-memory-leak-with-exceptions">discussion</a> ).</p>
<p>For deleting a memory, the situation gets complicated fast when it is the target of different pointers:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Class Student{...}
Class CourseA{
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    CourseA(<span style="color:#f92672">*</span>Student student)<span style="color:#f92672">:</span>Top(student) {}
    <span style="color:#f92672">~</span>A(){<span style="color:#75715e">// delete Top here?}
</span><span style="color:#75715e"></span>    Student<span style="color:#f92672">*</span> Top;
}
Class CourseB{
  Public:
    CourseB(<span style="color:#f92672">*</span>Student student)<span style="color:#f92672">:</span>Top(student) {}
    <span style="color:#f92672">~</span>B(){<span style="color:#75715e">// delete Top here?}
</span><span style="color:#75715e"></span>    Student<span style="color:#f92672">*</span> Top;
}
...
{
Student<span style="color:#f92672">*</span> Jack<span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Student();
CourseA<span style="color:#f92672">*</span> A<span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CourseA(Jack);
CourseB<span style="color:#f92672">*</span> B<span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CourseB(Jack);
<span style="color:#75715e">// delete Jack here, in CourseA or in CourseB destructor?
</span><span style="color:#75715e"></span>}
</code></pre></div><p>In the above example, three pointers target the same memory location, thus we cannot run <code>delete</code> for all of them as we face double-delete problems explained in the Delete section.</p>
<h2 id="conventions">Conventions</h2>
<p>If you start working with an existing project, look for pointer conventions in place. If you design a new code put some conventions in place for objects which delete pointers, and the ownership of pointers when they are passed to or returned from functions/objects.</p>
<p>For example, in the previous piece of code, we have to decide which object is the owner, i.e., which one
needs to outlive others. So we <code>delete</code> the pointer in that one and leave the rest as observers.</p>
<p>We can have <code>owner</code> as a type alias for <code>T</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">using</span> owner <span style="color:#f92672">=</span> T;
</code></pre></div><p>Now we can have a pointer policy for our code that pointers are defined by <code>owner</code> only when the class containing them is responsible for deleting them.</p>
<p>A simple example that owner acts as a raw pointer:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">A</span>{
    owner<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">*&gt;</span> p;
    <span style="color:#f92672">~</span>A(){<span style="color:#66d9ef">delete</span> p;}
};
</code></pre></div><p>Note that smart pointers, which are introduced in <em>C++11</em>, elegantly address this problem.</p>
<h2 id="dereference-class-members">Dereference class members</h2>
<p>A class member, method or variable, can be accessed via <code>-&gt;</code> operator:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    string name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Jack&#34;</span>;
}
Person<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Person();
std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> p<span style="color:#f92672">-&gt;</span>name <span style="color:#f92672">&lt;&lt;</span> endl;  <span style="color:#75715e">// Jack
</span></code></pre></div><h2 id="pass-by-pointer-vs-pass-by-reference">Pass by pointer vs pass by reference</h2>
<p>It is a good practice to pass objects especially the huge ones by a pointer. Instead of copying the whole data, only the pointer is passed:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DoSomething</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;*</span> v){
 <span style="color:#75715e">/* do something with v */</span>
}
...
<span style="color:#66d9ef">auto</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">10000</span>);
DoSomething(a);
</code></pre></div><p>I mostly prefer pass by reference as it feels easier to read. However, there is a difference between pass by pointer and pass by reference. When you pass by reference you guarantee that an outer scope always passes valid data to the fucntion. But when you pass data by pointer you may mean the pointer can be null and the function handles it.</p>
<p>When passing by pointer, the pointer itself passed by value</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p)
{
    <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;   <span style="color:#75715e">// the pointed memory changed
</span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;  <span style="color:#75715e">// p is changed within function not externally
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> q <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">0</span>);
    cout<span style="color:#f92672">&lt;&lt;</span> q <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 0x17d8b20
</span><span style="color:#75715e"></span>    f(q);
    cout<span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>q <span style="color:#f92672">&lt;&lt;</span> endl;  <span style="color:#75715e">// 100
</span><span style="color:#75715e"></span>    cout<span style="color:#f92672">&lt;&lt;</span> q <span style="color:#f92672">&lt;&lt;</span> endl;  <span style="color:#75715e">// 0x17d8b20: q is not changed
</span><span style="color:#75715e"></span>}
</code></pre></div><h2 id="constant">Constant</h2>
<p>A constant qualifier can be added to a pointer in different ways:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p <span style="color:#75715e">// constant or read-only target, pointer can be reassigned
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> p <span style="color:#75715e">// constant pointer cannot be reassigned
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> p <span style="color:#75715e">// both above constraints
</span></code></pre></div><p>The different versions are to constrain a pointer, reduce mistakes, improve readability and help compiler to optimise the code and catch errors.</p>
<p>The target of a constant-target pointer is not necessarily constant:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> a<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a; <span style="color:#75715e">// ok: read-only pointer
</span><span style="color:#75715e"></span>a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;  <span style="color:#75715e">// ok
</span><span style="color:#75715e"></span><span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>; <span style="color:#75715e">// Error:: against &#34;read-only&#34; contract
</span></code></pre></div><p>However, a constant target must be pointed only by a constant-target pointer.</p>
<h2 id="pointer-vs-reference-member">Pointer vs reference member</h2>
<p>A reference member of a class must be initialized in the constructor and it cannot be reassigned. However, a pointer member can be reassigned, freed, and null.</p>
<p>Use a reference member if an entity outside of the class controls the lifetime of the member and the entity outlives objects of this class.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">A</span> {
    A(<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> m_)<span style="color:#f92672">:</span>m(m_){};
    <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> m;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">50</span>);
    <span style="color:#66d9ef">auto</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> A(<span style="color:#f92672">*</span>p);
    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span> a<span style="color:#f92672">-&gt;</span>m; <span style="color:#75715e">// 50
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">delete</span> a; 
    <span style="color:#66d9ef">delete</span> p; <span style="color:#75715e">// p must outlive a
</span><span style="color:#75715e"></span>}
</code></pre></div><p>Use a pointer member if the member lifetime is controlled out of the class but the class handles a null pointer. Moreover, use a pointer if the class owns the member and responsible for deleting it.</p>
<h2 id="arrays-and-vectors">Arrays and vectors</h2>
<p>Pointers can be used to define arrays on the heap</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">5</span>]; <span style="color:#75715e">// dynamically allocated array
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> m <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">3</span>]{<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">5</span>}; <span style="color:#75715e">// C++11: initialize in place 
</span><span style="color:#75715e"></span>cout<span style="color:#f92672">&lt;&lt;</span> p[<span style="color:#ae81ff">2</span>]; <span style="color:#75715e">// prints 3rd element
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> q[<span style="color:#ae81ff">5</span>]; <span style="color:#75715e">// array of 5 integer pointers  
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> arr[<span style="color:#ae81ff">5</span>];  <span style="color:#75715e">// array of 5 integers
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> r <span style="color:#f92672">=</span> arr;  <span style="color:#75715e">// pointer points to first element of array
</span><span style="color:#75715e"></span>cout<span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>(r<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>); <span style="color:#75715e">// shows 3rd element of arr
</span></code></pre></div><p>A dynamic 2D array can be created with a pointer-to-pointer type</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#f92672">**</span>p;
<span style="color:#75715e">// dynamic array of pointers
</span><span style="color:#75715e">// each pointer is a row
</span><span style="color:#75715e"></span>p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>[<span style="color:#ae81ff">3</span>]; 

<span style="color:#75715e">// loop over rows
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; <span style="color:#f92672">++</span>i) {
  p[i] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">6</span>]; <span style="color:#75715e">// each row has 6 columns
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// p[i] points to dynamic array of int values
</span><span style="color:#75715e"></span>}
</code></pre></div><p>The elements can be accessed via <code>[]</code> operators</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> row<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, column<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;
p[row][column]<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>; <span style="color:#75715e">// 
</span></code></pre></div><p>In <em>C++</em>, we have the vector class which has many features and in terms of read-and-write is as fast as a raw array <a href="https://stackoverflow.com/questions/3664272/is-stdvector-so-much-slower-than-plain-arrays">see here</a>.  Generally, it&rsquo;s better to use a vector than a pointer to create an array.  But how to dereference a pointer to a vector? many ways:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">*</span>v <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">10</span>);

v<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">operator</span>[](<span style="color:#ae81ff">2</span>); <span style="color:#75715e">// using operator
</span><span style="color:#75715e"></span>(<span style="color:#f92672">*</span>v)[<span style="color:#ae81ff">2</span>]; <span style="color:#75715e">// dereferencing whole vector first
</span><span style="color:#75715e"></span>v<span style="color:#f92672">-&gt;</span>at(<span style="color:#ae81ff">2</span>); <span style="color:#75715e">// using At
</span><span style="color:#75715e"></span>v<span style="color:#f92672">-&gt;</span>size(); <span style="color:#75715e">//Get size
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>r <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>v; <span style="color:#75715e">// create alias using a reference
</span><span style="color:#75715e"></span>r[<span style="color:#ae81ff">2</span>]; <span style="color:#75715e">// index reference
</span></code></pre></div><h2 id="void-pointer">Void pointer</h2>
<p>All the pointers (int*, double*, string*, custom_class*) have the same datatype holding the memory address of different targets. So, <code>void*</code> pointer is a pointer the same as others pointing to some memory address but the data type of the target is unknown.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p;
<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>;
<span style="color:#66d9ef">double</span> d<span style="color:#f92672">=</span><span style="color:#ae81ff">1.5</span>;
p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i;
p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>d;
cout<span style="color:#f92672">&lt;&lt;*</span>(<span style="color:#66d9ef">double</span><span style="color:#f92672">*</span>)p; <span style="color:#75715e">// cast when dereferenced
</span></code></pre></div><p>It is a <em>C</em> language feature to write generic functions. But in <em>C++</em>, knowing <code>void*</code> tricks are not necessary since generic code can be elegantly written with templates, functors and interfaces.</p>
<h2 id="reading-pointers">Reading Pointers</h2>
<p>Reading pointers, we can understand how data are spread in the memory. We can also check the contiguity of objects. Pointers are printed in hexadecimal (hex) system which includes 16 (or 2⁴) characters {0-9,a-f} .</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">    <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">5</span>];
    cout <span style="color:#f92672">&lt;&lt;</span> p   <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 0x55b3ec05beb0 
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> p<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 0x55b3ec05beb4
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> p<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 0x55b3ec05beb8
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> p<span style="color:#f92672">+</span><span style="color:#ae81ff">3</span> <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 0x55b3ec05bebc
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> p<span style="color:#f92672">+</span><span style="color:#ae81ff">4</span> <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 0x55b3ec05bec0
</span></code></pre></div><p>&ldquo;0x&rdquo; represents the hex system. Focusing on the last numbers, {b0, b4, b8, bc, c0}, they increase by 4 units because an integer on the target machine was 4 bytes. In the hex system, we have b8+4=bc and b0+16=c0. Therefore, every 4 integers (or 2 doubles), the second last digit is incremented (b0 → c0).</p>

			<script>
				window.onscroll = function () {
					myFunction();
				};
				function myFunction() {
					var winScroll = document.body.scrollTop || document.documentElement.scrollTop;
					var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
					var scrolled = (winScroll / height) * 100;
					document.getElementById("myBar").style.width = scrolled + "%";
				}
			</script>
			<hr style="width:5%;text-align:left;margin-left:0;margin-top: 3em;border-top: 3px solid rgb(87, 86, 86);
			border-radius: 5px;">
			


  <h3>Related Tags</h3>
    <div id="tags">
        
        <span><a href="/tags/c&#43;&#43;">C&#43;&#43;</a> </span>
        
        <span><a href="/tags/pointers">Pointers</a> </span>
        
    </div>



			<hr style="width:5%;text-align:left;margin-left:0;margin-top: 3em;border-top: 3px solid rgb(87, 86, 86);
			border-radius: 5px;">
			
<div>
	<h3>Latest Posts</h3>
</div>
<div>
	<ul>
		
		<li><a href="/posts/ssh-port-forwarding/">SSH port forwarding to download files</a></li>
		
		<li><a href="/posts/cpp-span/">Span is a new norm in C&#43;&#43; codes</a></li>
		
		<li><a href="/posts/vs-code-extensions/">Essential VS Code font and extensions for C&#43;&#43;</a></li>
		
		<li><a href="/posts/perfect-forwarding-cpp/">An overview of C&#43;&#43; perfect forwarding</a></li>
		
		<li><a href="/posts/static-polymorphism-cpp/">Is C&#43;&#43; static polymorphism useful?</a></li>
		
	</ul>
</div>
	
		</article>
		<nav class="hide-on-mobile section-nav">
			<h3 class="ml-1">Table of contents</h3>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#definition">Definition</a></li>
    <li><a href="#memory-allocation">Memory Allocation</a></li>
    <li><a href="#delete">Delete</a></li>
    <li><a href="#null-usage">Null usage</a></li>
    <li><a href="#memory-leak">Memory leak</a></li>
    <li><a href="#conventions">Conventions</a></li>
    <li><a href="#dereference-class-members">Dereference class members</a></li>
    <li><a href="#pass-by-pointer-vs-pass-by-reference">Pass by pointer vs pass by reference</a></li>
    <li><a href="#constant">Constant</a></li>
    <li><a href="#pointer-vs-reference-member">Pointer vs reference member</a></li>
    <li><a href="#arrays-and-vectors">Arrays and vectors</a></li>
    <li><a href="#void-pointer">Void pointer</a></li>
    <li><a href="#reading-pointers">Reading Pointers</a></li>
  </ul>
</nav>
		</nav>		
	</div>
</main>

<script>
	window.addEventListener('DOMContentLoaded', () => {
		const observerForTableOfContentActiveState = new IntersectionObserver(entries => {
			entries.forEach(entry => {
				const id = entry.target.getAttribute('id');

				if (entry.intersectionRatio > 0) {					
					clearActiveStatesInTableOfContents();				
					document.querySelector(`nav li a[href="#${id}"]`).parentElement.classList.add('active');
				}
			});
		});		
		document.querySelectorAll('h1[id],h2[id],h3[id],h4[id]').forEach((section) => {
			observerForTableOfContentActiveState.observe(section);
		});

	});

	function clearActiveStatesInTableOfContents() {
		document.querySelectorAll('nav li').forEach((section) => {
			section.classList.remove('active');
		});
	}
</script>
 <footer>
    <div class="container home__footer-grid">
	<div class=" my-2">
	<form name="Subscription" method="POST" data-netlify="true" netlify-honeypot="ahani" action="/pages/sub-success">
		<p class="nedia">
		  <label> Name <input name="ahani" /></label>
		</p>
		<p><label for="emailinput">Subscribe so I notify you of new posts</label></p>
		<p class="display-flex">
		  <input id="emailinput" style="width: 18em;" class="mr-1" type="email" name="email" placeholder=" Email"/>
		  <button type="submit">Subscribe</button>
		</p>
	</form>
</div>
<div class="my-1 display-flex justify-start justify-md-end align-center">
	<p>Copyright &copy; 2021 <a href="https://iamsorush.com/">Sorush Khajepor</a></p>
</div>
</div>
</footer>



  
</body>

</html>