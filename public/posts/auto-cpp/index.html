<!DOCTYPE html>
<html lang="en-us">

<head>
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-179561110-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());
        gtag('config', 'UA-179561110-1');
    </script>
    
   
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge;chrome=1"> 
    <link rel="icon" href="/images/me.gif" type="image/gif">
    <title>C&#43;&#43; auto keyword makes your life easier</title>
    
    <meta name="description" content="In C&#43;&#43;, *auto* keyword can speed up coding and improve the maintainability of code. Here, I show cases that *auto* can make a difference."> 
    
    <meta name="author" content="map[name:Sorush Khajepor]">
    
    
    
    
    <link rel="stylesheet" href="https://iamsorush.com/css/style.min.css">
    
    
    
    <style>.icon{width:32px}.mr-1{margin-right:.5em}.mb-1{margin-bottom:.5em}.single-image{display:block;background-repeat:no-repeat;background-position:50%;margin-left:auto;margin-right:auto}.banner{width:100%;min-height:180px;background-image:url(/images/banner_430.jpg);padding:1em 0 2em 0}@media(min-width:430px){.banner{background-image:url(/images/banner.jpg)}}</style>
    

</head>

<body>
    
<div class="read-progress-container">
	<div class="progress-bar" id="myBar"></div>
</div>
<header class="header-black">
	<div class="container">

	<div class="home__header-grid"> 
		<div class="display-flex flex-column left-horizontal">
			<a class="scale-left-sm" href="https://iamsorush.com/">Sorush Khajepor</a>
			<span class="text-shadow-1">Researcher & Developer</span>
		</div>
		<div class="center justify-md-end">	
			<a href="https://github.com/sorush-khajepor" class="mr-1 icon" aria-label="Github">
				<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path fill="white" d="M512 0C229.25 0 0 229.25 0 512c0 226.25 146.688 418.125 350.156 485.812 25.594 4.688 34.938-11.125 34.938-24.625 0-12.188-0.469-52.562-0.719-95.312C242 908.812 211.906 817.5 211.906 817.5c-23.312-59.125-56.844-74.875-56.844-74.875-46.531-31.75 3.53-31.125 3.53-31.125 51.406 3.562 78.47 52.75 78.47 52.75 45.688 78.25 119.875 55.625 149 42.5 4.654-33 17.904-55.625 32.5-68.375C304.906 725.438 185.344 681.5 185.344 485.312c0-55.938 19.969-101.562 52.656-137.406-5.219-13-22.844-65.094 5.062-135.562 0 0 42.938-13.75 140.812 52.5 40.812-11.406 84.594-17.031 128.125-17.219 43.5 0.188 87.312 5.875 128.188 17.281 97.688-66.312 140.688-52.5 140.688-52.5 28 70.531 10.375 122.562 5.125 135.5 32.812 35.844 52.625 81.469 52.625 137.406 0 196.688-119.75 240-233.812 252.688 18.438 15.875 34.75 47 34.75 94.75 0 68.438-0.688 123.625-0.688 140.5 0 13.625 9.312 29.562 35.25 24.562C877.438 930 1024 738.125 1024 512 1024 229.25 794.75 0 512 0z"/></svg>
			</a>
			<a href="https://twitter.com/KhSorush" class="mr-1 icon" aria-label="Twitter">
				<svg id="Logo_FIXED" data-name="Logo â€” FIXED" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 400"><defs><style>.cls-1{fill:none;}.cls-2{fill:#1da1f2;}</style></defs><title>Twitter_Logo_Blue</title><rect class="cls-1" width="400" height="400"/><path class="cls-2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
			</a>
			<a href="https://scholar.google.co.uk/citations?user=16Y7-NsAAAAJ&hl=en" class="mr-1 icon" aria-label="Google Scholar">
				<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g data-name="Layer 2" id="Layer_2"><polygon fill="white" points="0.54 9 5 10.98 7 11.87 12 14.09 17 11.87 19 10.98 20 10.54 20 16 22 16 22 9.65 23.46 9 12 3.91 0.54 9"/><path fill="white" d="M18.45,18.89l.55-.27V13.17l-7,3.11L5,13.17v5.45l.55.27a14.45,14.45,0,0,0,12.9,0Z"/></g></svg>
			</a>
			<a href="https://stackoverflow.com/users/2543510/sorush" class="mr-1 icon" aria-label="Stackoverflow">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 120 120"><style>.st0{fill:#bcbbbb}.st1{fill:#f48023}</style><path class="st0" d="M84.4 93.8V70.6h7.7v30.9H22.6V70.6h7.7v23.2z"/><path class="st1" d="M38.8 68.4l37.8 7.9 1.6-7.6-37.8-7.9-1.6 7.6zm5-18l35 16.3 3.2-7-35-16.4-3.2 7.1zm9.7-17.2l29.7 24.7 4.9-5.9-29.7-24.7-4.9 5.9zm19.2-18.3l-6.2 4.6 23 31 6.2-4.6-23-31zM38 86h38.6v-7.7H38V86z"/></svg>
			</a>
			<a href="https://www.linkedin.com/in/sorushkh/" class="mr-1 icon" aria-label="Linkedin">
				<svg enable-background="new 0 0 32 32" height="32px" id="Layer_1" version="1.0" viewBox="0 0 32 32" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g><path d="M32,30c0,1.104-0.896,2-2,2H2c-1.104,0-2-0.896-2-2V2c0-1.104,0.896-2,2-2h28c1.104,0,2,0.896,2,2V30z" fill="#007BB5"/><g><rect fill="#FFFFFF" height="14" width="4" x="7" y="11"/><path d="M20.499,11c-2.791,0-3.271,1.018-3.499,2v-2h-4v14h4v-8c0-1.297,0.703-2,2-2c1.266,0,2,0.688,2,2v8h4v-7    C25,14,24.479,11,20.499,11z" fill="#FFFFFF"/><circle cx="9" cy="8" fill="#FFFFFF" r="2"/></g></g><g/><g/><g/><g/><g/><g/></svg>
			</a>
		</div>
    </div>
	</div>
</header>

<main>
	<article>
		<h1>C&#43;&#43; auto keyword makes your life easier</h1>
		<time>03 Dec 2020</time>
	</article>
	





    	



    








<style>
    .post__hero{
        background-image: url('https://iamsorush.com/images/gears_hu3d03a01dcc18bc5be0e67db3d8d209a6_169781_430x250_fill_q65_box_center.jpg');
        height: 250px;
    }
    @media (min-width: 430px) {
        .post__hero{
        background-image: url('https://iamsorush.com/images/gears_hu3d03a01dcc18bc5be0e67db3d8d209a6_169781_1280x400_fill_q65_box_center.jpg');
        height: 400px;
        }
    }   
</style>
<div class="single-image post__hero"></div>
	<div class="article-nav" id="article-nav-id">
		<article class="overlay-top">
			<h2 id="introduction">Introduction</h2>
<p>Since <em>C++11</em>, a compiler can deduce the type of a variable being declared from its initializer using <code>auto</code> keyword. It is also called placeholder type specifier.</p>
<h2 id="general-behavior">General Behavior</h2>
<p><code>auto</code> infers the type of a variable from its initializer. The variable gets a copy of the initializer</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> i;
<span style="color:#66d9ef">auto</span> j <span style="color:#f92672">=</span> i; <span style="color:#75715e">// j is int contains a copy of i
</span></code></pre></div><p><code>auto</code> deduces reference type as a value type. To enforce being a reference, use <code>auto&amp;</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> i <span style="color:#f92672">=</span> m; <span style="color:#75715e">// i is an alias to m
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> j <span style="color:#f92672">=</span> i; <span style="color:#75715e">// j is int contains a copy of i
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> k <span style="color:#f92672">=</span> m; <span style="color:#75715e">// k is int&amp; and alias to m
</span></code></pre></div><p><code>auto</code> can Not infer <code>const</code> qualifier. To enforce that, use <code>const auto</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">auto</span> j <span style="color:#f92672">=</span> m; <span style="color:#75715e">// j is int (non-const)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> k <span style="color:#f92672">=</span> m; <span style="color:#75715e">// k is const int
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> l <span style="color:#f92672">=</span> i; <span style="color:#75715e">// l is const int, holds a copy of i
</span></code></pre></div><p><code>auto&amp;</code> infers <code>const</code> qualifier</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> j <span style="color:#f92672">=</span> i; <span style="color:#75715e">// const int&amp;, alias for i
</span></code></pre></div><h2 id="literals">Literals</h2>
<p><code>auto</code> figures out the below types:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">auto</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// int
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> j<span style="color:#f92672">=</span> <span style="color:#ae81ff">7ul</span>; <span style="color:#75715e">// unsigned long
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.0</span>; <span style="color:#75715e">// double
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.0f</span>; <span style="color:#75715e">// float
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> c <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;A&#39;</span>; <span style="color:#75715e">// char
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hi&#34;</span>; <span style="color:#75715e">// char const*
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> b <span style="color:#f92672">=</span> true; <span style="color:#75715e">// bool
</span></code></pre></div><p>From C++14, we can have std::string literals:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std; <span style="color:#75715e">// This is necessary
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hellow&#34;</span>s <span style="color:#75715e">// std::string, note the s operator. 
</span></code></pre></div><h2 id="classes">Classes</h2>
<p>Custom classes are also inferred:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LongNameClass</span> {};
<span style="color:#66d9ef">auto</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LongNameClass(); <span style="color:#75715e">// a is LongNameClass*
</span></code></pre></div><p>List initializer:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">auto</span> l <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>}; <span style="color:#75715e">// l is std::initializer_list&lt;int&gt;
</span></code></pre></div><p>Long name types can be easily replaced by <code>auto</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> m; 
<span style="color:#66d9ef">auto</span> n <span style="color:#f92672">=</span> m;

<span style="color:#66d9ef">auto</span> p <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(); <span style="color:#75715e">//unique pointer
</span><span style="color:#75715e"></span>
std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> vec(<span style="color:#ae81ff">100</span>);
<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> r <span style="color:#f92672">=</span> vec;
</code></pre></div><p>A vector iterator type can be hidden with auto</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// type of i is std::vector&lt;double&gt;::iterator
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> i <span style="color:#f92672">=</span> vec.begin(); i <span style="color:#f92672">!=</span> vec.end(); i<span style="color:#f92672">++</span>){
    cout<span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>i;
}
</code></pre></div><p>The elements of a vector can be easily read:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>};

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> x : vec)
    cout <span style="color:#f92672">&lt;&lt;</span> x ;
</code></pre></div><h2 id="pointers">Pointers</h2>
<p>A pointer type is also deduced:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> i;
<span style="color:#66d9ef">auto</span> p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i; <span style="color:#75715e">// int*
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> q <span style="color:#f92672">=</span> p;  <span style="color:#75715e">//int*
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> r <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">5</span>]; <span style="color:#75715e">// int*
</span></code></pre></div><p>We can emphasize pointer type with <code>*</code> for readability. The outcome of the example below is the same as the previous one:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> i;
<span style="color:#66d9ef">auto</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i; <span style="color:#75715e">// int*
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span><span style="color:#f92672">*</span> q <span style="color:#f92672">=</span> p; <span style="color:#75715e">// int*
</span></code></pre></div><p>Note both <code>const auto</code> and <code>auto const</code> are turned to a constant pointer with a mutable target. We still can customise the outcome pointer with <code>*</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> r <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i; <span style="color:#75715e">// int* const: constant pointer, mutable target
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">const</span> s <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i; <span style="color:#75715e">// int* const
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> t <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i;<span style="color:#75715e">// int* const
</span><span style="color:#75715e"></span>    
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">*</span> u <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i;<span style="color:#75715e">// const int*: mutable pointer, constant target
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">*</span> v <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i;<span style="color:#75715e">// const int* or int const* 
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> w <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>i;<span style="color:#75715e">// const int* const: pointer &amp; target constant
</span></code></pre></div><h2 id="references">References</h2>
<p>By default, <code>auto</code> deduces reference as the value type</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> y;
<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> p <span style="color:#f92672">=</span> y;
<span style="color:#66d9ef">auto</span> x <span style="color:#f92672">=</span> p; <span style="color:#75715e">// x is int and contains a copy of p
</span></code></pre></div><p>This value copy behavior can dramatically create a problem if you just want to create an alias to a big size vector. To overcome it, we have two options: <code>auto&amp;</code> or <code>decltype(auto)</code> since <em>C++14</em></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> y;
<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> x <span style="color:#f92672">=</span> y; <span style="color:#75715e">// x is an alias to y
</span><span style="color:#75715e"></span><span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) z <span style="color:#f92672">=</span> (y); <span style="color:#75715e">// z is an alias to y
</span></code></pre></div><p>Note, we should do the same when initializing with a function</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> f(<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> i){ <span style="color:#66d9ef">return</span> <span style="color:#f92672">++</span>i;};
<span style="color:#66d9ef">int</span> m<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">auto</span>  j <span style="color:#f92672">=</span> f(m);<span style="color:#75715e">// j is int but a copy return of f
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> k <span style="color:#f92672">=</span> f(m);<span style="color:#75715e">// k is int&amp; and an alias to return of f
</span><span style="color:#75715e"></span><span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) l <span style="color:#f92672">=</span> f(m); <span style="color:#75715e">// l is int&amp; and an alias to return of f
</span></code></pre></div><h2 id="const">Const</h2>
<p>Using bare <code>auto</code>, <code>const</code> is not inferred. We have to use <code>auto&amp;</code>, <code>const auto</code>, <code>const auto&amp;</code> or <code>decltype(auto)</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">auto</span> j <span style="color:#f92672">=</span> m; <span style="color:#75715e">// j is int
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> k <span style="color:#f92672">=</span> m; <span style="color:#75715e">// k is const int&amp;
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> l <span style="color:#f92672">=</span> m <span style="color:#75715e">// l is const int
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> n <span style="color:#f92672">=</span> m <span style="color:#75715e">// n is const int&amp; 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) o <span style="color:#f92672">=</span> m <span style="color:#75715e">// o is const int
</span></code></pre></div><h2 id="auto-vs-decltypeauto">auto vs decltype(auto)</h2>
<p>In the examples shown in this post, we understand that <code>auto</code> alone cannot convert to a constant or reference type. To do so, we should use <code>auto&amp;</code> or <code>const auto</code>. They give the programmer more control over the declared type.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> f(<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> i){<span style="color:#66d9ef">return</span> <span style="color:#f92672">++</span>i;}
<span style="color:#66d9ef">auto</span> i <span style="color:#f92672">=</span> f(<span style="color:#ae81ff">2</span>);<span style="color:#75715e">// i gets a copy of f(2)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> j <span style="color:#f92672">=</span> f(<span style="color:#ae81ff">2</span>);<span style="color:#75715e">// j is an alias of f(2)
</span></code></pre></div><p>But sometimes, like a wrapper, we want the compiler to deduce the type exactly as it is:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) FindTaxReturn(<span style="color:#66d9ef">double</span><span style="color:#f92672">&amp;</span> data){
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Compute</span>(data);
}

</code></pre></div><h2 id="auto-vs-decltype">auto vs decltype</h2>
<p><code>auto</code> deduces the type of a variable when declared with the help of  its initializer</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">auto</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// int
</span></code></pre></div><p><code>decltype</code> infers the type of expression which can be used for variable declaration or injection into
a template</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">f</span>(){<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;}
<span style="color:#66d9ef">decltype</span>(f()) i; <span style="color:#75715e">// i is integer
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(f())<span style="color:#f92672">&gt;</span> v; <span style="color:#75715e">// vector&lt;int&gt;, cannot be done with auto
</span></code></pre></div><p>Note that <code>f()</code> within <code>decltype(f())</code> is not called. In fact during compilation and before the program is run, the declarations are concluded to be <code>int i</code>, <code>vector&lt;int&gt; v</code>.</p>
<h2 id="test">Test</h2>
<p>A good IDE like VS Code is your best friend to assess the outcome of <code>auto</code>. However, you can check the types using metafunctions in <code>&lt;type_traits&gt;</code> header:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;type_traits&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
  <span style="color:#66d9ef">auto</span> x <span style="color:#f92672">=</span> true;
  cout<span style="color:#f92672">&lt;&lt;</span>is_same<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(x), <span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;::</span>value;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>To ensure the type is correctly inferred, we can implement <code>static_assert</code>. It throws a compile-time
error if the type is not correct:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">static_assert</span>(std<span style="color:#f92672">::</span>is_same<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(x), <span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;::</span>value, <span style="color:#e6db74">&#34;x must be bool&#34;</span>);
</code></pre></div><p>Another solution to check types is to use <code>typeid</code> as below.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;typeinfo&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">auto</span> x<span style="color:#f92672">=</span><span style="color:#ae81ff">1.0</span>u;
    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#66d9ef">typeid</span>(x).name()<span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>endl;

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>The printed output is compiler dependent. <em>GCC</em> on my machine produces strings like <em>i</em>, <em>m</em>, or very long texts. To interpret them, use command <code>c++filt -t</code> in the terminal. So for <em>j</em> output, we run</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">c++filt -t j
</code></pre></div><p>It produced <code>unsigned int</code> for me. <code>typeid</code> is not as reliable as <code>typetraits</code> functions, read <a href="https://en.cppreference.com/w/cpp/types/type_info/name">here</a> to for more info.</p>
<h2 id="function">Function</h2>
<p>At function definition, the type can be inferred with the aid of
its trailing return type (C++14)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b){
    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b; <span style="color:#75715e">// return type is int
</span><span style="color:#75715e"></span>}
</code></pre></div><p>Therefore, we have to guide the compiler if a function is only declared but not defined</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">subtract</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b); <span style="color:#75715e">// Error: cannot figure out return type
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">multiply</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">int</span>; <span style="color:#75715e">// works fine 
</span></code></pre></div><p>The compiler must be notified when the return type is ambiguous. In the example below, the compiler cannot deduce the type of <code>f</code>, that&rsquo;s why we mention it as <code>-&gt; double</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">bool</span> cond) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">double</span>
{
    <span style="color:#66d9ef">if</span> (cond)
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// returns int
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span>
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2.5</span>; <span style="color:#75715e">// returns double
</span><span style="color:#75715e"></span>}

</code></pre></div><p><em>C++20</em> lets us have <code>auto</code> function arguments. The function below adds containers that have <code>size()</code> method, <code>[]</code> operator, and <code>+</code> operator for their elements. The outcome type is automatically promoted, for example, <code>vector&lt;int&gt;</code> plus <code>vector&lt;double&gt;</code> is <code>vector&lt;double&gt;</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;array&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">add</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> a1, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> a2)
{
    <span style="color:#66d9ef">auto</span> n <span style="color:#f92672">=</span>  a1.size();
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(a1[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> a2[<span style="color:#ae81ff">0</span>])<span style="color:#f92672">&gt;</span> result(n);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">decltype</span>(n) i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
		result[i] <span style="color:#f92672">=</span> a1[i] <span style="color:#f92672">+</span> a2[i];
	<span style="color:#66d9ef">return</span> result;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    
    array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#ae81ff">3</span><span style="color:#f92672">&gt;</span> a <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>};
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> b <span style="color:#f92672">=</span> {<span style="color:#ae81ff">3.1</span>,<span style="color:#ae81ff">2.1</span>,<span style="color:#ae81ff">1.1</span>};
    <span style="color:#66d9ef">auto</span> r <span style="color:#f92672">=</span> add(a,b);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> item:r)
        cout<span style="color:#f92672">&lt;&lt;</span>item<span style="color:#f92672">&lt;&lt;</span>endl; <span style="color:#75715e">// 4.1 4.1 4.1
</span><span style="color:#75715e"></span>    
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="auto-in-header-file">Auto in header file</h2>
<p>A function with <code>auto</code> argument is acceptable in a header file (<em>C++20</em>). A function, which returns <code>auto</code>, must declare return type with <code>-&gt;</code> operator. The example below is on <a href="https://github.com/sorush-khajepor/CppExamples/tree/main/basic/example002">GitHub</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// a.h
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">A</span>
{
    T x;
    <span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">Add</span>(<span style="color:#66d9ef">auto</span> a)<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">decltype</span>(a<span style="color:#f92672">+</span>x);
};
</code></pre></div><p>Note that the type of the function argument is relevant just to the function scope, but the type it returns affects the scope the function is called in. That&rsquo;s why the header must hint at the return type.</p>
<p>In the  <em>.cpp</em> file, all the necessary classes must be instantiated:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// compiler GCC 10.3 flag -std=c++20
</span><span style="color:#75715e">// a.cpp
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;a.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">auto</span> A<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>Add(<span style="color:#66d9ef">auto</span> a)<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">decltype</span>(a<span style="color:#f92672">+</span>x){
    <span style="color:#66d9ef">return</span> a<span style="color:#f92672">+</span>x;
}

<span style="color:#75715e">// intantiate classes
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span>
<span style="color:#66d9ef">auto</span> A<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;::</span>Add(<span style="color:#66d9ef">double</span> a)<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">decltype</span>(a<span style="color:#f92672">+</span>x);

<span style="color:#66d9ef">template</span>
<span style="color:#66d9ef">auto</span> A<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>Add(<span style="color:#66d9ef">int</span> a)<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">decltype</span>(a<span style="color:#f92672">+</span>x);

<span style="color:#75715e">// main.cpp
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;a.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
  A<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> a1{.x<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>};
  A<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> a2{.x<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>};
  A<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> a3{.x<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>};
  
  <span style="color:#66d9ef">auto</span> b <span style="color:#f92672">=</span> a1.Add(<span style="color:#ae81ff">1.0</span>); <span style="color:#75715e">// OK. From header, compiler knows b is double
</span><span style="color:#75715e"></span>
  std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>a1.Add(<span style="color:#ae81ff">20.0</span>)<span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// OK
</span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>a2.Add(<span style="color:#ae81ff">20</span>)<span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">//OK
</span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>a3.Add(<span style="color:#ae81ff">20.0</span>)<span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// Error: double A&lt;int&gt;::Add&lt;double&gt;(double) not found!
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}


</code></pre></div><h2 id="lambda">Lambda</h2>
<p><code>auto</code> is perfect for specifying the type of lambda functions.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">auto</span> l <span style="color:#f92672">=</span> [](<span style="color:#66d9ef">int</span> i) { <span style="color:#66d9ef">return</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; };
</code></pre></div><h2 id="templates">Templates</h2>
<p><code>auto</code> can infer the return type of a templated function (C++14).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">auto</span> add(T t, U u) 
{ <span style="color:#66d9ef">return</span> t <span style="color:#f92672">+</span> u; } <span style="color:#75715e">// during compilation, type of t+u is deduced.  
</span></code></pre></div><p>If the return type is not clear for the compiler, we can help it with <code>decltype</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">auto</span> f(T t, U u, <span style="color:#66d9ef">bool</span> cond) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">decltype</span>(t<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#75715e">// tell compiler, return type is of t+1
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">if</span> (cond)
        <span style="color:#66d9ef">return</span> t<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
 
    <span style="color:#66d9ef">return</span> u<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
};
</code></pre></div>
			<script>
				window.onscroll = function () {
					myFunction();
				};
				function myFunction() {
					var winScroll = document.body.scrollTop || document.documentElement.scrollTop;
					var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
					var scrolled = (winScroll / height) * 100;
					document.getElementById("myBar").style.width = scrolled + "%";
				}
			</script>
			<hr style="width:5%;text-align:left;margin-left:0;margin-top: 3em;border-top: 3px solid rgb(87, 86, 86);
			border-radius: 5px;">
			


  <h3>Related Tags</h3>
    <div id="tags">
        
        <span><a href="/tags/c&#43;&#43;">C&#43;&#43;</a> </span>
        
    </div>



			<hr style="width:5%;text-align:left;margin-left:0;margin-top: 3em;border-top: 3px solid rgb(87, 86, 86);
			border-radius: 5px;">
			
<div>
	<h3>Latest Posts</h3>
</div>
<div>
	<ul>
		
		<li><a href="/posts/build-gcc11/">Build GCC 11 from source in Ubuntu</a></li>
		
		<li><a href="/posts/ssh-port-forwarding/">SSH port forwarding to download files</a></li>
		
		<li><a href="/posts/cpp-span/">Span is a new norm in C&#43;&#43; codes</a></li>
		
		<li><a href="/posts/vs-code-extensions/">Essential VS Code font and extensions for C&#43;&#43;</a></li>
		
		<li><a href="/posts/perfect-forwarding-cpp/">An overview of C&#43;&#43; perfect forwarding</a></li>
		
	</ul>
</div>
	
		</article>
		<nav class="hide-on-mobile section-nav">
			<h3 class="ml-1">Table of contents</h3>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#general-behavior">General Behavior</a></li>
    <li><a href="#literals">Literals</a></li>
    <li><a href="#classes">Classes</a></li>
    <li><a href="#pointers">Pointers</a></li>
    <li><a href="#references">References</a></li>
    <li><a href="#const">Const</a></li>
    <li><a href="#auto-vs-decltypeauto">auto vs decltype(auto)</a></li>
    <li><a href="#auto-vs-decltype">auto vs decltype</a></li>
    <li><a href="#test">Test</a></li>
    <li><a href="#function">Function</a></li>
    <li><a href="#auto-in-header-file">Auto in header file</a></li>
    <li><a href="#lambda">Lambda</a></li>
    <li><a href="#templates">Templates</a></li>
  </ul>
</nav>
		</nav>		
	</div>
</main>

<script>
	window.addEventListener('DOMContentLoaded', () => {
		const observerForTableOfContentActiveState = new IntersectionObserver(entries => {
			entries.forEach(entry => {
				const id = entry.target.getAttribute('id');

				if (entry.intersectionRatio > 0) {					
					clearActiveStatesInTableOfContents();				
					document.querySelector(`nav li a[href="#${id}"]`).parentElement.classList.add('active');
				}
			});
		});		
		document.querySelectorAll('h1[id],h2[id],h3[id],h4[id]').forEach((section) => {
			observerForTableOfContentActiveState.observe(section);
		});

	});

	function clearActiveStatesInTableOfContents() {
		document.querySelectorAll('nav li').forEach((section) => {
			section.classList.remove('active');
		});
	}
</script>
 <footer>
    <div class="container home__footer-grid">
	<div class=" my-2">
	<form name="Subscription" method="POST" data-netlify="true" netlify-honeypot="ahani" action="/pages/sub-success">
		<p class="nedia">
		  <label> Name <input name="ahani" /></label>
		</p>
		<p><label for="emailinput">Subscribe so I notify you of new posts</label></p>
		<p class="display-flex">
		  <input id="emailinput" style="width: 18em;" class="mr-1" type="email" name="email" placeholder=" Email"/>
		  <button type="submit">Subscribe</button>
		</p>
	</form>
</div>
<div class="my-1 display-flex justify-start justify-md-end align-center">
	<p>Copyright &copy; 2021 <a href="https://iamsorush.com/">Sorush Khajepor</a></p>
</div>
</div>
</footer>



  
</body>

</html>