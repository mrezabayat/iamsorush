
Which integer to choose for C++: int, int_fast, int_least

int vs int_fast64_t vs
=========
how to create flexible compile-time structure, with unique interface
contiguous - a unique reusable core base class 
#include <iostream>
#include <cstdlib>
#include <array>
struct int_t{
    typedef int mytype;    
};
struct double_t{
    typedef double mytype;    
};

template<class T>
struct V{
    typename T::mytype a=1.5;
};

int main()
{
    V<int_t> v;
    V<double_t> g;
    std::cout <<v.a<<" "<<g.a<< std::endl;
}
=========

generc mpi send/recv object of objects same template class

#include <iostream>
#include <cstdlib>
#include <array>

struct ParticleSpecs_2D{
    static const size_t Dim=2;
    static const size_t DataSize=0;
};

struct ParticleSpecs_Radius2D: ParticleSpecs_2D{
    static const size_t RadiusIndex = 0;
    static const size_t RadiusSize = 1;
    static const size_t DataSize=RadiusSize;
};

struct ParticleSpecs_MassVelocity3D{
    static const size_t Dim=3;
    static const size_t MassIndex = 0;
    static const size_t MassSize = 1;
    static const size_t VelocityIndex = 1;
    static const size_t VelocitySize = 3;
    static const size_t DataSize=VelocitySize+MassSize;
};


template<class T>
struct Particle{
    double Position[T::Dim];
    double Data[T::DataSize];
    static T Specs;
};

template<>
struct Particle<ParticleSpecs_2D>{
    double Position[ParticleSpecs_2D::Dim];
    static ParticleSpecs_2D Specs;
};


using namespace std;
int main()
{
    Particle<ParticleSpecs_2D> p1;
    cout<< sizeof(p1)<<" "; //16
    cout<< sizeof(p1.Position)<<endl; //16
  //  std::cout<< sizeof(p2.data)<<std::endl; // Error: no member 'data'
    cout<<"===="<<endl;
    
    Particle<ParticleSpecs_Radius2D> p2;
    cout<< sizeof(p2)<<" "; // 24
    cout<< sizeof(p2.Position)<<" "; //16
    cout<< sizeof(p2.Data)<<endl; // 8
    cout<<"===="<<endl;
    
    typedef ParticleSpecs_MassVelocity3D U;
    Particle<U> p3;
    cout<< sizeof(p3)<<" "; // 56
    cout<< sizeof(p3.Position)<<" "; // 24 = 3 double = (X,Y,Z)
    cout<< sizeof(p3.Data)<<endl; // 32 = 4 double = mass + (Vx Vy Vz)
    
    for (size_t i=0;i<p3.Specs.Dim;i++)
        p3.Position[i] = i*10; // 0 10 20
    
    p3.Data[p3.Specs.MassIndex] = 30;
    
    auto v = &p3.Data[p3.Specs.VelocityIndex];
    for (size_t i=0;i<p3.Specs.VelocitySize;i++)
        *(v+i) = i*10+40; // 50 60 70
    
    for (size_t i=0;i<p3.Specs.Dim;i++)
        cout<< p3.Position[i]<<" ";//0 10 20
    for (size_t i=0;i<p3.Specs.DataSize;i++)
        cout<< p3.Data[i]<<" "; //30 40 50 6
    
}


==========




#include <iostream>
#include <memory>
#include <vector>
using namespace std;

template<size_t dim, class T>
struct Specs{
    static const size_t Dim = dim;
    using Type = T;
};

template<class S>
struct Particle{
    typename S::Type Position[S::Dim];
    using Specs = S;
};

template<class S>
struct Particle_Radius: Particle<S>{
    typename S::Type Radius;
};

template<class S>
struct Particle_MassVelocity: Particle_Radius<S>{
    typename S::Type Mass;
    typename S::Type Velocity[S::Dim];
};

struct Dynamics{
    int stuff;
};

template<class P>
struct Block{
    vector<unique_ptr<Dynamics>> dynamics;
    vector<P> particles;
    Particle<typename P::Specs>& Get(size_t i){return particles[i];}
    
    void print(){
        for (auto& p:particles)
            cout<<p.Position[0]<<" "<<p.Position[1];
        cout<<endl;
    }
};

template<class P>
struct Block1{
    using Type = typename P::Specs::Type;
    vector<P> particles;
    Type extent[P::Dim];
};


int main()
{
    
    Particle_Radius<Specs<2,double> > particle;
    
    particle.Position[0]=4.1; particle.Position[1]=5.1;
    Block<decltype(particle)> block;  
    block.particles.push_back(particle);
    block.print();
    
    /*
    Particle_Radius<2,int> p2;
    p2.Position[0]=4.1; p2.Position[1]=5.1;
    Block<decltype(p2)> block1;  
    block1.particles.push_back(p2);
    block1.print();
    
    */
    
   }
